<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<!-- 20180426-->
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>

<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="reflection," />










<meta name="description" content="Java反射机制是指在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。用一句话总结就是反射可以实现在运行时(Runtime)知道任意一个类的属性和方法。">
<meta name="keywords" content="reflection">
<meta property="og:type" content="article">
<meta property="og:title" content="Reflection">
<meta property="og:url" content="http://yoursite.com/2018/05/02/Reflection/index.html">
<meta property="og:site_name" content="Xudong&#39;s blogs">
<meta property="og:description" content="Java反射机制是指在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。用一句话总结就是反射可以实现在运行时(Runtime)知道任意一个类的属性和方法。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/11861611-66c2212619def74a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/11861611-a2363588cf851230.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/11861611-eeceebe6d869e70b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2018-05-04T18:06:01.028Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Reflection">
<meta name="twitter:description" content="Java反射机制是指在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。用一句话总结就是反射可以实现在运行时(Runtime)知道任意一个类的属性和方法。">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/11861611-66c2212619def74a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/05/02/Reflection/"/>





  <title>Reflection | Xudong's blogs</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Xudong's blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">email:2228998096@qq.com    wechat:yxd19940114</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/02/Reflection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="杨旭东">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xudong's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Reflection</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-02T23:19:33+08:00">
                2018-05-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程语言/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Java反射机制是指在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。<br>用一句话总结就是反射可以实现在<strong>运行时(Runtime)</strong>知道任意一个类的属性和方法。<br><a id="more"></a></p>
<h1 id="一-反射的定义"><a href="#一-反射的定义" class="headerlink" title="一. 反射的定义"></a>一. 反射的定义</h1><p>反射(Reflection)是Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。<br>Oracle官方对反射的解释是</p>
<blockquote>
<p>Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.<br>The API accommodates applications that need access to either the public members of a target object (based on its runtime class) or the members declared by a given class. It also allows programs to suppress default reflective access control.</p>
</blockquote>
<p>简而言之，通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。<br>程序中一般的对象的类型都是在编译期就确定下来的，而Java反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，<strong>即使这个对象的类型在编译期是未知的。</strong><br>反射的核心是JVM在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。</p>
<h1 id="二-反射的重要性"><a href="#二-反射的重要性" class="headerlink" title="二. 反射的重要性"></a>二. 反射的重要性</h1><p>当程序运行时，允许改变程序结构或变量类型，这种语言称为动态语言。我们认为java并不是动态语言，但是它却有一个非常突出的动态相关机制即反射。<br>IT行业里这么说，没有反射也就没有框架，现有的框架都是以反射为基础。在实际项目开发中，用的最多的是框架，填的最多的是类，反射这一概念就是将框架和类揉在一起的调和剂。所以反射才是接触项目开发的敲门砖。</p>
<h1 id="三-使用反射的流程"><a href="#三-使用反射的流程" class="headerlink" title="三. 使用反射的流程"></a>三. 使用反射的流程</h1><p>根据<a href="http://www.oracle.com/technetwork/articles/java/javareflection-1536171.html" target="_blank" rel="noopener">官方API</a>写就行了，大致流程就是:</p>
<ul>
<li>获取特定类的 <strong>Class</strong>类，即该类对应的字节码，共三种方法：</li>
</ul>
<ol>
<li>类名.class</li>
<li>对象名.getClass()</li>
<li><strong>Class.forName(“要加载的类全名”)</strong></li>
</ol>
<ul>
<li><p>调用 Class 对象的 <strong>getConstructor(Class&lt;?&gt;… parameterTypes)</strong>获取构造方法对象</p>
</li>
<li><p>调用是构造方法类 Constructor  的 <strong> newInstance(Object… initargs)</strong> 方法新建对象</p>
</li>
</ul>
<ul>
<li><p>调用Class对象的 <strong>getMethod(String name, Class&lt;?&gt;… parameterTypes)</strong>获取方法对象</p>
</li>
<li><p>调用方法对象类Method 的 <strong>invoke(Object obj, Object… args)</strong> 方法，调用对象上相应方法</p>
</li>
</ul>
<h1 id="四-反射的原理"><a href="#四-反射的原理" class="headerlink" title="四. 反射的原理"></a>四. 反射的原理</h1><p>本节内容整理自<a href="https://www.imooc.com/video/3733/0" target="_blank" rel="noopener">慕课网教学</a></p>
<h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><h3 id="类是不是对象"><a href="#类是不是对象" class="headerlink" title="类是不是对象?"></a>类是不是对象?</h3><p>在面向对象的世界里，一切皆是对象。而在java语言中，有两个东西特殊：static修饰的东西不是对象，但是它属于类；普通的数据类型不是对象，例如：int a = 5;它不是面向对象，但是它有其包装类 Integer 或者分装类来弥补了它。除了以上两种不是面向对象，其余的<strong>包括类也有它的面向对象</strong>，类是 java.lang.Class 的<strong>实例化对象</strong>（注意<strong>C</strong>是大写）。</p>
<h3 id="可以用new关键字实例化Class对象吗"><a href="#可以用new关键字实例化Class对象吗" class="headerlink" title="可以用new关键字实例化Class对象吗?"></a>可以用new关键字实例化Class对象吗?</h3><p>对于普通的对象，我们一般都会这样创建和表示(实例化)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Foo foo1 =<span class="keyword">new</span> Foo();</span><br></pre></td></tr></table></figure>
<p>我们会下意识地这样实例化Class类的对象(错误)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c =<span class="keyword">new</span> Class();<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
<p>查看Class源码，原因是Class类构造器是私有的，只有JVM可以创建Class的对象，因此不可以像普通类一样new一个Class对象，我们无法在代码中显式地声明一个 Class 对象。</p>
<blockquote>
<p> Only the Java Virtual Machine creates Class objects.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Private constructor. Only the Java Virtual Machine creates Class objects.</span></span><br><span class="line"><span class="comment"> * This constructor is not used and prevents the default constructor being</span></span><br><span class="line"><span class="comment"> * generated.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Class</span><span class="params">(ClassLoader loader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Initialize final field for classLoader.  The initialization value of non-null</span></span><br><span class="line">    <span class="comment">// prevents future JIT optimizations from assuming this final field is null.</span></span><br><span class="line">    classLoader = loader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><p>虽然我们不能用构造器new一个Class对象，但是却可以通过已有的类得到一个Class的 <strong>实例对象</strong>，共有三种方式，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. Class c1 = Foo .class;</span><br><span class="line"><span class="comment">//这说明任何一个类都有一个  隐含的静态成员变量class，  这种方式是通过获取类的静态成员变量class得到的</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. Class c2 = foo1.getClass();</span><br><span class="line"><span class="comment">//code1是Code的一个对象，这种方式是通过一个类的对象的getClass()方法获得的</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. Class c3 = Class.forName(<span class="string">"com.test.reflect.Foo "</span>);</span><br><span class="line"><span class="comment">//这种方法是Class类调用forName方法，通过一个类的全量限定名获得</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(c1 == c2)? or System.out.println(c1 == c3)?</span><br></pre></td></tr></table></figure>
<p>答案是肯定的，返回值为ture。这表明不论c1 or c2 or c3都代表了F类的类类型，也就是说一个类只可能是Class类的一个实例对象。<br>c1、c2、c3都是Class的对象，叫做<strong>Code这个类的类类型（Class Type）</strong>。<br><strong><em>类类型是反射的基础。</em></strong></p>
<h3 id="通过类类型获取该类的对象"><a href="#通过类类型获取该类的对象" class="headerlink" title="通过类类型获取该类的对象"></a>通过类类型获取该类的对象</h3><p>已经得到了类类型，可以通过类类型的newInstance()方法创建某个类的对象实例以及调用方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Foo foo= (Foo )foo1.newInstance(); <span class="comment">// 必须要有无参的构造器</span></span><br><span class="line">foo.print();</span><br></pre></td></tr></table></figure>
<h2 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h2><p> 程序执行分为编译器和运行期，编译时刻加载一个类就称为静态加载类，运行时刻加载类称为动态加载类。为了更好理解动态加载类和静态加载类的区别，抛开IDE工具，用记事本手写类,方便我们利用cmd命令行手动编译和运行一个类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Office</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"Word"</span>.equals(args[<span class="number">0</span>]))&#123;   </span><br><span class="line">            <span class="comment">// 静态加载类，在编译时加载</span></span><br><span class="line">            Word w = <span class="keyword">new</span> Word();</span><br><span class="line">            w.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"Excel"</span>.equals(args[<span class="number">0</span>]))&#123;</span><br><span class="line">            Excel e = <span class="keyword">new</span> Excel();</span><br><span class="line">            e.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用javac命令编译Office.java<br><img src="http://upload-images.jianshu.io/upload_images/11861611-66c2212619def74a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="静态加载"><br>由于我们new的两个类Word和Excel没有编译，所以报错了，这就是静态加载类的缺点，即必须在编译时期就加载所有可能用到的类，而我们希望实现的是运行时用到哪个类就加载哪个类，下面通过动态加载类来加以改进。<br>改进以后的类：OfficeBetter.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OfficeBetter</span></span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 动态加载类，在运行时加载</span></span><br><span class="line">            Class c = Class.forName(args[<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">// 通过类类型，创建该类对象</span></span><br><span class="line">            OfficeAble oa = (OfficeAble)c.newInstance();</span><br><span class="line">            oa.start();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里动态加载了名为args[0]的类，而args[0]是在运行期输入给main方法的第一个参数，如果你输入Word那么就会加载Word.java，这时候就需要在与OfficeBetter.java相同路径下面创建Word.java；同理，如果你输入Excel就需要加载Excel.java了。<br>其中OfficeAble是一个接口，上面动态加载的类如Word、Excel就是实现了OfficeAble，体现了多态的思想，这种动态加载和多态的思想可以使具体功能和代码解耦，也就是随时想添加某个功能（如Word和Excel都不要了，我要PPT）都能动态添加，而不改动原来的代码。<strong>满足对修改封闭对扩展开放的思想，方便日后热插拔。</strong></p>
<p>其中OfficeAble接口如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OfficeAble</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>word类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Word</span> <span class="keyword">implements</span> <span class="title">OfficeAble</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"word...starts..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按顺序编译、运行上面的类：<br><img src="http://upload-images.jianshu.io/upload_images/11861611-a2363588cf851230.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="动态加载"></p>
<p>总之反射机制的优点就是可以实现动态创建对象和编译，体现出很大的灵活性，特别是在J2EE的开发中 它的灵活性就表现的十分明显。比如，一个大型的软件，不可能一次就把把它设计的很完美，当这个程序编译后，发布了，当发现需要更新某些功能时，我们不可能要用户把以前的卸载，再重新安装新的版本，假如这样的话，这个软件肯定是没有多少人用的。采用静态的话，需要把整个程序重新编译一次才可以实现功能 的更新，而采用反射机制的话，它就可以不用卸载，只需要在运行时才动态的创建和编译，就可以实现该功能。 </p>
<h2 id="获取类的信息"><a href="#获取类的信息" class="headerlink" title="获取类的信息"></a>获取类的信息</h2><p>一句话，类中有什么信息，它就可以获得什么信息，不过前提是得知道类的名字，否则巧妇难为无米之炊。<br>我们都知道一个类包括属性，普通方法和构造方法，这一节我们就学习如何通过类类型得到类的基本信息。</p>
<h3 id="获取类的成员方法信息"><a href="#获取类的成员方法信息" class="headerlink" title="获取类的成员方法信息"></a>获取类的成员方法信息</h3><p>在Java中，类的成员方法也是一个对象，它是java.lang.reflect.Method的一个对象，所以我们通过<strong>java.lang.reflect.Method</strong>里面封装的方法来获取这些信息。</p>
<h4 id="获取单个方法"><a href="#获取单个方法" class="headerlink" title="获取单个方法"></a>获取单个方法</h4><p>单独获取某一个方法是通过<strong>Class</strong>类的以下方法获得的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getDeclaredMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span> <span class="comment">// 得到该类所有的方法，不包括父类的</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span> <span class="comment">// 得到该类所有的public方法，包括父类的</span></span></span><br></pre></td></tr></table></figure>
<p><strong>eg.</strong><br>两个参数分别是<strong>方法名</strong>和方法参数类的<strong>类类型</strong>列表。<br>例如类 A有如下一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// code body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在知道A有一个对象a，那么就可以通过以下方式获取print方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class c = a.getClass();</span><br><span class="line">Method method = c.getDeclaredMethod(<span class="string">"print"</span>, String.class, <span class="keyword">int</span>.class);</span><br></pre></td></tr></table></figure>
<h4 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h4><p>得到方法以后通过Method类的以下方法调用该方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object… args)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>eg.</strong><br>两个参数分别是这个方法所属的对象和这个方法需要的参数，还是用上面的例子来说明，通过：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method.invoke(a, <span class="string">"hello"</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>和通过普通调用效果完全一样，这就是方法的反射，invoke()方法可以反过来将其对象作为参数来调用方法，完全跟正常情况反了过来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.print(<span class="string">"hello"</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h3 id="获取类的成员变量信息"><a href="#获取类的成员变量信息" class="headerlink" title="获取类的成员变量信息"></a>获取类的成员变量信息</h3><p>类的成员变量也是一个对象，它是java.lang.reflect.Field的一个对象，所以我们通过java.lang.reflect.Field里面封装的方法来获取这些信息。</p>
<h4 id="单独获取某个成员变量"><a href="#单独获取某个成员变量" class="headerlink" title="单独获取某个成员变量"></a>单独获取某个成员变量</h4><p>通过Class类的以下方法实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Field <span class="title">getDeclaredField</span><span class="params">(String name)</span> <span class="comment">// 获得该类自身声明的所有变量，不包括其父类的变量</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Field <span class="title">getField</span><span class="params">(String name)</span> <span class="comment">// 获得该类自所有的public成员变量，包括其父类变量</span></span></span><br></pre></td></tr></table></figure>
<p>参数是成员变量的名字。<br><strong>eg</strong><br>一个类A有如下成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n;</span><br></pre></td></tr></table></figure>
<p>如果A有一个对象a，那么就可以这样得到其成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class c = a.getClass();</span><br><span class="line">Field field = c.getDeclaredField(<span class="string">"n"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="获取类的构造函数"><a href="#获取类的构造函数" class="headerlink" title="获取类的构造函数"></a>获取类的构造函数</h3><p>同上，类的成构造函数也是一个对象，它是java.lang.reflect.Constructor的一个对象，所以我们通过<strong>java.lang.reflect.Constructor</strong>里面封装的方法来获取这些信息。</p>
<h4 id="单独获取某个构造函数"><a href="#单独获取某个构造函数" class="headerlink" title="单独获取某个构造函数"></a>单独获取某个构造函数</h4><p>通过<strong>Class</strong>类的以下方法实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Constructor&lt;T&gt; <span class="title">getDeclaredConstructor</span><span class="params">(Class&lt;?&gt;... parameterTypes)</span> <span class="comment">// 获得该类所以public构造器，包括父类</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(Class&lt;?&gt;... parameterTypes)</span> <span class="comment">// 获得该类所以public构造器，包括父类</span></span></span><br></pre></td></tr></table></figure>
<p>这个参数为构造函数参数类的类类型列表。<br><strong>eg</strong><br>类A有如下一个构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(String a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// code body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么就可以通过以下的方式来获取这个构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructor = a.getDeclaredConstructor(String.class, <span class="keyword">int</span>.class);</span><br></pre></td></tr></table></figure>
<h1 id="五-通过反射了解集合泛型的本质"><a href="#五-通过反射了解集合泛型的本质" class="headerlink" title="五.  通过反射了解集合泛型的本质"></a>五.  通过反射了解集合泛型的本质</h1><blockquote>
<p>Java中集合的泛型，是防止错误输入的，只在编译阶段有效，绕过编译到了运行期就无效了。即Java编程思想里说的泛型的“擦除”。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.trigl.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericEssence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List list1 = <span class="keyword">new</span> ArrayList(); <span class="comment">// 没有泛型 </span></span><br><span class="line">        List&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">// 有泛型</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 1.首先观察正常添加元素方式，在编译器检查泛型，</span></span><br><span class="line"><span class="comment">         * 这个时候如果list2添加int类型会报错</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        list2.add(<span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">//      list2.add(1); // 报错！list2有泛型限制，只能添加String，添加int报错</span></span><br><span class="line">        System.out.println(<span class="string">"list2的长度是："</span> + list2.size()); <span class="comment">// 此时list2长度为1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 2.然后通过反射添加元素方式，在运行期动态加载类，首先得到list1和list2</span></span><br><span class="line"><span class="comment">         * 的类类型相同，然后再通过方法反射绕过编译器来调用add方法，看能否插入int</span></span><br><span class="line"><span class="comment">         * 型的元素</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class c1 = list1.getClass();</span><br><span class="line">        Class c2 = list2.getClass();</span><br><span class="line">        System.out.println(c1 == c2); <span class="comment">// 结果：true，说明类类型完全相同</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证：我们可以通过方法的反射来给list2添加元素，这样可以绕过编译检查</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method m = c2.getMethod(<span class="string">"add"</span>, Object.class); <span class="comment">// 通过方法反射得到add方法</span></span><br><span class="line">            m.invoke(list2, <span class="number">20</span>); <span class="comment">// 给list2添加一个int型的，上面显示在编译器是会报错的</span></span><br><span class="line">            System.out.println(<span class="string">"list2的长度是："</span> + list2.size()); <span class="comment">// 结果：2，说明list2长度增加了，并没有泛型检查</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 综上可以看出，在编译器的时候，泛型会限制集合内元素类型保持一致，但是编译器结束进入</span></span><br><span class="line"><span class="comment">         * 运行期以后，泛型就不再起作用了，即使是不同类型的元素也可以插入集合。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/11861611-eeceebe6d869e70b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输出结果"></p>
<p>参考文章<br><a href="https://blog.csdn.net/my_truelove/article/details/51289217" target="_blank" rel="noopener">浅谈 Java 中的 Class 类</a><br><a href="https://www.jianshu.com/p/6277c1f9f48d" target="_blank" rel="noopener">谈谈Java反射机制</a><br><a href="https://www.sczyh30.com/posts/Java/java-reflection-1/" target="_blank" rel="noopener">深入解析Java反射（1） - 基础</a><br><a href="https://brianway.github.io/2016/01/08/javase-learn-note-1-Reflect/" target="_blank" rel="noopener">java基础巩固笔记(1)-反射</a><br><a href="https://blog.csdn.net/trigl/article/details/51042403" target="_blank" rel="noopener">Java反射入门</a><br><a href="http://www.oracle.com/technetwork/articles/java/javareflection-1536171.html" target="_blank" rel="noopener">Using Java Reflection</a><br><a href="https://www.imooc.com/video/3733/0" target="_blank" rel="noopener">慕课网教学</a><br><a href="https://blog.csdn.net/changlei_shennan/article/details/60868962" target="_blank" rel="noopener">Java反射机制（源码反射优势解析）</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/reflection/" rel="tag"><i class="fa fa-tag"></i> reflection</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/04/27/markdown入门/" rel="next" title="markdown入门">
                <i class="fa fa-chevron-left"></i> markdown入门
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/05/04/Spring入门/" rel="prev" title="Spring入门">
                Spring入门 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">杨旭东</p>
              <p class="site-description motion-element" itemprop="description">种一棵树最好的时间是十年前，其次是现在</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/stoneyang94" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.jianshu.com/u/f7b90f4a10ae" target="_blank" title="简书">
                      
                        <i class="fa fa-fw fa-book"></i>简书</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#一-反射的定义"><span class="nav-number">1.</span> <span class="nav-text">一. 反射的定义</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二-反射的重要性"><span class="nav-number">2.</span> <span class="nav-text">二. 反射的重要性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三-使用反射的流程"><span class="nav-number">3.</span> <span class="nav-text">三. 使用反射的流程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#四-反射的原理"><span class="nav-number">4.</span> <span class="nav-text">四. 反射的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Class类"><span class="nav-number">4.1.</span> <span class="nav-text">Class类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类是不是对象"><span class="nav-number">4.1.1.</span> <span class="nav-text">类是不是对象?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可以用new关键字实例化Class对象吗"><span class="nav-number">4.1.2.</span> <span class="nav-text">可以用new关键字实例化Class对象吗?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类类型"><span class="nav-number">4.1.3.</span> <span class="nav-text">类类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过类类型获取该类的对象"><span class="nav-number">4.1.4.</span> <span class="nav-text">通过类类型获取该类的对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态加载"><span class="nav-number">4.2.</span> <span class="nav-text">动态加载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取类的信息"><span class="nav-number">4.3.</span> <span class="nav-text">获取类的信息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#获取类的成员方法信息"><span class="nav-number">4.3.1.</span> <span class="nav-text">获取类的成员方法信息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#获取单个方法"><span class="nav-number">4.3.1.1.</span> <span class="nav-text">获取单个方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#调用方法"><span class="nav-number">4.3.1.2.</span> <span class="nav-text">调用方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取类的成员变量信息"><span class="nav-number">4.3.2.</span> <span class="nav-text">获取类的成员变量信息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#单独获取某个成员变量"><span class="nav-number">4.3.2.1.</span> <span class="nav-text">单独获取某个成员变量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取类的构造函数"><span class="nav-number">4.3.3.</span> <span class="nav-text">获取类的构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#单独获取某个构造函数"><span class="nav-number">4.3.3.1.</span> <span class="nav-text">单独获取某个构造函数</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#五-通过反射了解集合泛型的本质"><span class="nav-number">5.</span> <span class="nav-text">五.  通过反射了解集合泛型的本质</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">杨旭东</span>

  
</div>

<!-- 20180426 -->
<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>


<!-- 20180425

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>

-->

<!-- 20180425

  <span class="post-meta-divider">|</span>

-->

<!-- 20180425

  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>

-->



        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

  <!--页面点击小红心 -->
  <script type="text/javascript" src="/js/src/love.js"></script>>
    <!--背景动画 -->
  <script type="text/javascript" src="/js/src/background.js"></script>>
</body>
</html>
