---
title: 类加载机制
date: 2018-08-01 19:05:36
tags: JVM
categories: JVM
---
博主最近复习深入理解JVM一书，整理归纳，以形成系统认识和方便日后复习。
本文主要介绍类加载机制


类是在**运行期间动态加载**的。

<!-- more -->

# 类的加载
类的加载指的是将类的`.class`文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个`java.lang.Class`对象，用来封装类在方法区内的数据结构。
类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。



## 类的生命周期

![类的生命周期](http://upload-images.jianshu.io/upload_images/11861611-944dde0b477d53cb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

包括以下 7 个阶段：

- 加载（Loading）
- 验证（Verification）
- 准备（Preparation）
- 解析（Resolution）
- 初始化（Initialization）
- 使用（Using）
- 卸载（Unloading）

其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。

# 类初始化时机--When
那么什么情况下需要开始类加载过程的第一个阶段，加载到内存中呢？
由主动引用触发，被动引用不会触发。

## 有且仅有5类主动引用：
虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况**必须**对类进行初始化（加载、验证、准备都会随着发生）：

### 1.  特殊字节码指令
遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：
- 使用 new 关键字实例化对象的时候
- 读取或设置一个类的静态字段（被 final 修饰、已在编译器把结果放入常量池的静态字段除外）的时候
- 调用一个类的静态方法的时候。

### 2.  反射调用
使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。

### 3.  父类
当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。

### 4.  主类
当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类。

### 5.  特殊方法句柄
当使用 JDK.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；

以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。

## 被动引用的常见例子

### 1. 通过子类引用父类的静态字段 
这种情况不会导致子类的初始化，因为对于静态字段，只有直接定义静态字段的类才会被触发初始化，子类不是定义这个静态字段的类，自然不能被实例化。

```java
System.out.println(SubClass.value); // value 字段在 SuperClass 中定义
```

### 2. 通过数组定义来引用类，不会触发该类的初始化 

```java
SuperClass[] sca = new SuperClass[10];
```

### 3. 常量不会触发定义常量的类的初始化 
因为常量在编译阶段会存入调用常量的类的常量池中，本质上并没有引用定义这个常量的类，所以不会触发定义这个常量的类的初始化。

```java
System.out.println(ConstClass.HELLOWORLD);
```

# 类加载过程

包含了加载、验证、准备、解析和初始化这 5 个阶段。

## 1. 加载

加载是类加载的一个阶段，不要混淆。

- 加载过程完成以下三件事：

1.  通过一个类的全限定名来`获取`定义此类的二进制字节流
2.  将这个字节流所代表的静态存储结构`转化`为**方法区**的运行时存储结构
3.  在内存中`生成`一个代表这个类的**Class 对象**，作为方法区这个类的各种数据的**访问入口**

相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。
其中二进制字节流可以从以下方式中获取：

  - 从 ZIP 包读取
这很常见，最终成为日后 JAR、EAR、WAR 格式的基础。
  - 从网络中获取
这种场景最典型的应用是 Applet。
  - 运行时计算生成
这种场景使用得最多得就是动态代理技术，在 java.lang.reflect.Proxy 中，就是用了 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。
  - 由其他文件生成
典型场景是 JSP 应用，即由 JSP 文件生成对应的 Class 类。
  - 从数据库读取
这种场景相对少见，例如有些中间件服务器（如 SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。


加载阶段完成后，虚拟机外部的**二进制字节流**就按照虚拟机所需的格式存储在**方法区**之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。

## 2. 验证--确保被加载的类的正确性

确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

验证阶段大致会完成4个阶段的检验动作：

### 1)文件格式验证

验证字节流是否`符合` Class 文件**格式**的规范，并且能被当前版本的虚拟机处理。

1. 是否以**魔数0xCAFEBABE开头**
2. **主、次版本号**是否在当前虚拟机处理范围之内。 
3. **常量池的常量**中是否有不被支持的常量类型（检查常量tag标志）。
4. 指向常量的**各种索引值**中是否有指向**不存在的常量**或**不符合类型的常量**。 
5. Class文件中各部分及文件本身是否有**被删除或附加**的其他信息
……

### 2)元数据验证

对字节码描述的信息进行**语义**分析，以保证其描述的信息符合 Java 语言规范的要求。

1.这个类是否有**父类**（除了java.lang.Object之外，所有的类都应当有父类）。 
2.这个类的**父类**是否继承了不允许被继承的类（被final修饰的类）； 
3.如果这个类不是抽象类，是否实现了其父类或接口中要求实现的所有方法。 
4.类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载。）
……

### 3)字节码验证

通过数据流和控制流分析，确保程序语义是合法、符合逻辑的。

### 4)符号引用验证

发生在虚拟机将符号引用转换为直接引用的时候，对类自身以外（常量池中的各种符号引用）的信息进行**匹配性校验**


验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

### 3. 准备--为类的静态变量分配内存，并将其初始化为默认值
`类变量`是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是**方法区的内存**

- 注意：
1. `实例变量`**不会在这阶段分配内存**，它将会在对象实例化时随着对象一起分配在 Java 堆中。
2. 初始值“通常情况”下是**数据类型的零值**

```
public  static  int value =  123;
```

那变量value在准备阶段过后的初始值为0而不是~~123~~，因为这时候尚未开始执行任何Java方法，而value赋值为123的putstatic指令是程序被编译后，存放于类构造器<clinit>方法之中，所以把value赋值为123的动作在初始化阶段才会执行。 
而“特殊情况”，如：

```java
public static final int value = 123；
```

如果类变量是常量，那么会按照表达式来进行初始化(例子中的123)，而不是赋值为 ~~0~~



### 4. 解析--把类中的符号引用转换为直接引用

将常量池的符号引用替换为直接引用的过程。

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。

符号引用就是一组符号来描述目标，可以是任何字面量。
直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

### 5. 初始化
初始化阶段才真正开始执行类中的定义的 Java 程序代码。初始化阶段即虚拟机执行**类构造器 `<clinit>()` 方法**的过程。

在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。

#### `<clinit>()`特点
`<clinit>() `方法具有以下特点：
是由编译器自动收集类中所有**类变量**的赋值动作和**静态语句块**（static{} 块）中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。

特别注意的是，静态语句块只能访问到定义在它之前的类变量，`定义在它之后的类变量只能赋值，不能访问`。例如以下代码：

```
public  class  Test  {
    static  {
    i =  0;  // 给变量赋值可以正常编译通过
    System.out.print(i);  // 这句编译器会提示“非法向前引用”
    }
    static  int i =  1;
}
```


#### `<clinit>()`超类和派生类
与类的构造函数（或者说实例构造器 <init>()）不同，不需要显式的调用父类的构造器。**虚拟机会自动保证在子类的`<clinit>() `方法运行之前，`父类`的 `<clinit>()` 方法已经执行结束`**。因此虚拟机中第一个执行 `<clinit>() `方法的类肯定为 java.lang.Object。

由于父类的 `<clinit>()` 方法先执行，也就意味着父类中定义的静态语句块要优于子类的变量赋值操作。如下面的例子所示，输出结果为2而不是1。

```
public class Parent {  
    public static int A = 1;  
    static{  
       A = 2;  
    }  
}    

public class Sub extends Parent{  
    public static int B = A;  
}   

public class Test {  
    public static void main(String[] args) {  
       System.out.println(Sub.B);  
    }  
}
```

##### `<clinit>() `不必须
`<clinit>()` 方法对于类或接口不是必须的，如果一个类中不包含静态语句块，也没有对类变量的赋值操作，编译器可以不为该类生成 `<clinit>()` 方法。

#####  接口的`<clinit>()` 用到才执行
接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 <clinit>() 方法。但接口与类不同的是，执行接口的 <clinit>() 方法不需要先执行父接口的 <clinit>() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 <clinit>() 方法。

##### `<clinit>()` 多线程安全
虚拟机会保证一个类的 `<clinit>()` 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 `<clinit>()` 方法，其它线程都会阻塞等待，直到活动线程执行 `<clinit>()` 方法完毕。如果在一个类的 `<clinit>()` 方法中有耗时的操作，就可能造成多个进程阻塞，在实际过程中此种阻塞很隐蔽。

参考文章
周志明，深入理解Java虚拟机：JVM高级特性与最佳实践，机械工业出版社
[【深入理解JVM】：类加载机制](https://blog.csdn.net/u011080472/article/details/51329315)
[Jvm笔记总结(八)：虚拟机类加载机制](https://blog.csdn.net/u010046451/article/details/79156790)