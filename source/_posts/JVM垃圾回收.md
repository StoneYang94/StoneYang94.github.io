---
title: JVM垃圾回收
date: 2018-07-02 23:39:18
tags: JVM垃圾回收
categories: JVM
---
Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人想出来。

<!-- more -->

# 一. 概述

## 垃圾回收意义
电脑的内存是有限的，如果一段程序申请了一块内存空间并执行完计算之后，会导致这块内存被占用，可用内存就变少。如果不释放内存、回收垃圾，电脑内存迟早耗尽。
C语言中有malloc、free等于内存分配以及内存释放的函数。而Java中使用垃圾收集机制来整理内存空间。

## 垃圾回收怎么做
垃圾收集（Garbage Collection，GC）需要完成的三件事情：
1.  what
哪些内存需要回收？
2.  when
什么时候回收？
3.  how
如何回收？

当要排查各种内存溢出、内存泄漏问题时，当垃圾收集称为系统达到更高并发量的瓶颈时，我们就需要对这些”自动化”的技术实施必要的监控和调节。

## 发生GC的内存区域---where
1.  `程序计数器、虚拟机栈、本地方法栈`3个区域随线程而生，随线程而灭；每一个栈帧中分配多少内存基本上在类结构确定下来的时候就已知。因此这几个区域的内存分配和回收都具有**确定性**，不需过多考虑回收问题，方法结束或者线程结束时，内存自然就随之回收了。
2.  `Java堆和方法区`则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，只有在程序处于运行期间才知道会创建哪些对象，这部分内存的分配和回收都是`动态`的，垃圾收集器所关注的是这部分内存！

# 二. 对象已死吗？---what

垃圾回收器在对堆进行回收前，首要确定的事情就是这些对象之间哪些还存活着，哪些已经死去？
分析方法：引用计数法、可达性分析法

## 引用计数算法(Reference Counting)

###定义
给对象添加一个引用计数器
- 当一个地方引用它时，计数器值就+1
- 当引用失效时，计数器值就-1
- 任何时刻计数器为0的对象就是不可能被再使用的

### 优点
实现简单，判定效率高

### 缺点
由于其很难解决对象之间**相互循环引用**的问题，故主流Java虚拟机里面都没有选用Refrence Couting算法来管理内存

```java
public class ReferenceCountingGC {
     public Object instance = null;
     private static final int _1MB = 1024 * 1024;
     // 这个成员属性的唯一意义就是占点内存，以便在能在GC日志中看清楚是否有回收过
     private byte[] bigSize = new byte[2 * _1MB];
     public static void testGC() {
         ReferenceCountingGC objA = new ReferenceCountingGC();
         ReferenceCountingGC objB = new ReferenceCountingGC();
         objA.instance = objB;
         objB.instance = objA;
         objA = null;
         objB = null;
         // 假设在这行发生GC，objA和objB是否能被回收？
         System.gc();
     }
}
```

实际上这两个对象已经不可能再被访问，但是因为它们互相引用着对方，导致它们的引用计数值都不为0，引用计数算法无法通知GC收集器回收它们。

## 可达性分析算法（Reachability Analysis）

### 定义
判断对象存活的基本思路：
1. 通过一系列的称为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）
2. 当一个对象到GC Roots没有任何引用链相连（即GC Roots到这个对象不可达）时，则证明此对象是不可用的

![GC Roots判断对象存活](http://p7vxw6hv7.bkt.clouddn.com/18-6-30/26399415.jpg)

### GC Roots对象
Java语言中，可作为GC Roots对象包括：

1.  虚拟机栈（栈帧中的本地变量表）中引用的对象
2.  方法区中类静态属性引用的对象
3.  方法区中常量引用的对象
4.  本地方法栈中JNI（即一般的Native方法）引用的对象

## 再谈引用

JDk1.2之后，Java对引用概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用4种，4种强度一次逐渐减弱。

1.  强引用（`Strong Reference`）是指在程序代码之中普遍存在的，类似`Object obj=new Object()`这类的引用，只要强引用存在，对象就不会发生GC；
2.  软引用（`Soft Reference`）是用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生OOM异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收后还没有足够的内存，才会抛出OOM异常。
3.  弱引用（`Weak Reference`）是用来描述非必须对象的，强度比软引用更弱，被弱引用关联的对象只能生存到下一次GC发生之前。当垃圾回收器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
4.  虚引用（`Phantom Reference`）也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

## 回收方法区

### 效率
在方法区中进行垃圾收集的性价比一般比较低；而在Heap中，尤其是在新生代，常规应用进行一次垃圾收集一般回收70%~95%的空间，而永久代的垃圾收集效率远低于此

### 回收什么
永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类；
1. 回收废弃常量与回收Java堆中的对象类似
2. 判定一个类是否是无用的类条件相对苛刻：
2.1 该类所有实例都已被回收，即Java堆中不存在该类的任何实例；
2.2 加载该类的`ClassLoader`已经被回收；
2.3 该类对应的`java.lang.Class`对象没有在任何地方被引用，无法在任何地方通过反射访问该方法。

### 针对场景
在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。

# 三. 垃圾收集算法---how

只介绍内存回收的方法论（算法思想及发展过程），不讨论具体算法实现。

## 标记-清除算法（Mak-Sweep） 

### 定义
MS算法分标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

![Mak-Sweep](http://p7vxw6hv7.bkt.clouddn.com/18-7-2/79832376.jpg)

### 不足
1. 效率问题
标记和清除两个过程的效率都不高
2. 空间问题
标记清除之后会产生**大量不连续的内存碎片**，空间碎片太多后导致以后程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前出发一次垃圾收集动作；

## 复制算法（Coping）

### 定义
Coping算法将可用内存按容量划分为大小相等的两块，每次使用其中一块。当这一块的内存用完了，就将还存活的对象复制到另一块上面，然后再把已使用的内存清理掉。

![Coping](http://p7vxw6hv7.bkt.clouddn.com/18-7-2/25551918.jpg)

### 优缺点
- 优点
每次对整个半区进行回收，内存分配时不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效；
- 不足
提高效率的代价是将**内存缩小到原来的一半**
   
### 对缺点的改进 
**现代商业虚拟机都采用 复制算法（Coping） 来回收新生代**

#### 1.空间分配
- 新生代中的对象一般98%是朝生夕死，无需按照1:1比例来划分内存空间，而是将内存分为1块较大的Eden（伊甸园）空间和2块较小的Survivor（幸存者）空间，每次使用Eden和其中1块Survivor
- HotSpot VM默认Eden和Survivor的比例是8:1:1，即只浪费10%的内存

#### 2.具体过程
回收时，将Eden和Survivor中还存活的对象一次性复制到另外一个Survivor空间中，最后清理掉Eden和刚才用过的Survivor空间。

#### 3.分配担保
98%的对象可回收只是一般场景下的数据，无法保证每次回收都只有不多于10%的对象存活，所以当Survivor空间不足时，需要依赖其他内存（老年代）进行`分配担保（Handle Promotion），让对象进入老年代。

## 标记-整理算法（Mark-Compact）

### copying的不足
复制算法在对象存活率较高时复制操作较多，效率会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以对应被使用内存中的所有对象都100%存活的极端情况，所以老年代一般不直接选用这种算法。

### 定义
根据老年代的特点，提出标记-整理（Mark-Compact）算法，标记过程仍然与`标记-清除`算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理调用端边界以外的内存。

![Mark-Compact](http://p7vxw6hv7.bkt.clouddn.com/18-7-2/76555149.jpg)


### 对比
标记-清除vs 标记-整理

![对比](http://p7vxw6hv7.bkt.clouddn.com/18-7-2/96407470.jpg)

## 分代收集算法（Generational Collection）

当前商业虚拟机的垃圾收集都采用分代收集(Generational Collection)算法，根据对象存活周期的不同将内存分为几块。

一般把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法

|分代|特点|算法|
|---|---|---|
|新生代|每次垃圾回收时都发现有大批对象死去,只有少量对象存活|复制算法，以少量对象复制的成本
|老年代|对象存活率高、没有额外空间对其进行分配担保|标记-清理或标记-整理算法来

# 四. HotSpot的算法实现
主要介绍JVM如何`发起`内存回收。具体如何`进行`内存回收则和垃圾回收器有关。

HotSpot虚拟机上实现对象存活判断算法和垃圾收集算法时，必须对算法的执行效率有严格的考量，才能保证虚拟机高效运行。

## 可达性分析具体流程
可达性分析中会发生：Stop The World 和枚举根节点。

### 1. Stop The World
可达性分析对执行时间的敏感体现在GC停顿上，在整个分析期间，整个执行系统看起来就像冻结在某个时间点上，不能出现在分析过程中对象引用关系还在不断变化的情况。这导致GC进行时，必须停顿所有Java执行线程（Stop The World）。即使在号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也必须要停顿。
至于为什么在GC时要发生STW，有一个很适合的比喻：你妈妈在给你打扫房间的时候，肯定让你在老实呆着，否则她一边打扫，你一边扔纸屑，这房间还能打扫完？

### 2. 枚举根节点
简言之就是列举出所有“GC Roots”。在可达性分析中，通过GC Roots 节点找引用链判断对象在链情况。
而可以作为GC Roots的节点主要是全局性引用（常量、类变量）与执行上下文（栈帧中的本地变量表）中，现在很多应用仅方法区就有数百兆。**如果要逐个检查GC Roots节点，那必然会消耗很多时间。**目前主流Java虚拟机使用的都是准确式GC，所以在执行系统停顿下来后，并不需要一个不漏的检查所有执行上下文和全局引用的位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。在HotSpot的实现中，是使用一组称为OopMap（Ordinary Object Pointer,普通对象指针)的数据结构来达到这个目的的。在类加载完成时，HotSpot就把对象内具体偏移量上是什么类型的数据计算出来，在JIT(Just-In-Time Compiler)编译过程中，也会在特定的位置（Safepoint）记录下栈和寄存器中哪些位置是引用。这样，GC在扫描时就可以直接得知这些信息。

## 安全点（Safepoint）

### OopMap缺点
1.  在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举，但是可能会导致引用关系变化
2.  OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，将会需要大量的额外空间，这样GC的空间成本将会变得很高。

### 用安全点弥补OopMap缺点
HotSpot没有为每条指令都生成OopMap，只是在**特定的位置**记录了这些信息，这些位置称为安全点(Sapfepoint)，即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。

- 安全点的选定
1.  宏观准则
安全点的选定既不能太少以至于让GC等待时间太长，也不能过于频繁以至于过分增大运行时的负荷。
2.  具体标准
安全点的选定基本上是以程序`是否具有让程序长时间执行的特性`为标准选定的，长时间执行的最明显特性就是指令序列复用，如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。

### 线程怎么到安全点
如何在GC发生时让所有线程（这里不包括执行JNI调用的线程）都跑到最近的安全点上再停顿下来，有两张方案可供选择：

#### 1.  抢先式中断（Preemptive Suspension）
- 不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它跑到安全点
- 现在**几乎没有**虚拟机实现采用抢先式中断来暂停线程从而响应GC事件

#### 2.  主动式中断（Voluntary Suspension）
当GC需要中断线程的时候，不直接对线程进行操作，仅仅简单的设置一个标志，**各个线程执行时主动去轮询这个标志**，发现中断标志为真时就自己中断挂起（VM将内存页设置为不可读，线程会产生自陷异常，在预先注册异常处理器中暂停线程实现等待），轮询标志的地方和安全点是重合的。

## 安全区域（Safe Region）

### 产生背景
Safepoint机制保证了程序执行时，在不太长时间内就会遇到可进入GC的Safepoint；但是当程序不执行（没有CPU分配时间）的时候（如线程出于Sleep状态或者Block状态），**这时线程无法响应JVM的中断请求**，走到安全的地方中断挂起，JVM也不可能等待线程重新分配CPU时间。

对于这种情况，就需要安全区域（Safe Region）来解决。

### 安全区域定义
- 安全区域是指在一段代码片中，**引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的**
- 可以将Safe Region看作被扩展了的Safepoint

### 工作原理
执行函数在进入安全区域时设置ready flag。在它离开安全区域以前，它先检查GC是否完成了枚举（或者收集），并且不再需要执行函数呆在阻塞状态。如果是真，它就向前执行，离开安全区域； 否则，它就像安全点一样阻塞他自己。

# 五. 垃圾收集器
垃圾收集算法是方法论，而垃圾收集器是具体的实现。

![垃圾收集器](http://p7vxw6hv7.bkt.clouddn.com/18-7-2/39895128.jpg)

## 相关概念

### 并发和并行

这两个名词都是并发编程中的概念，在谈论垃圾收集器的上下文语境中，它们可以解释如下。

- 并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态
- 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上

## Minor GC 和 Full GC

- 新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。
- 老年代GC（Major GC / Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。

## 吞吐量

吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即
`吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）`。

eg:虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。

## 收集器

### Serial收集器---Client模式下首选

Serial收集器是最基本、发展历史最悠久的收集器。它是一种**单线程**垃圾收集器，这就意味着在其进行垃圾收集的时候需要暂停其他的线程，也就是之前提到的”Stop the world“。虽然这个过程是在用户不可见的情况下把用户正常的线程全部停掉，听起来有点狠，这点是很难让人接受的。Serial、Serial Old收集器的工作示意图如下：

![Serial](http://p7vxw6hv7.bkt.clouddn.com/18-7-2/22759043.jpg)

尽管有以上不能让人接受的地方，但是Serial收集器还是有其优点的：简单而高效，对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得较高的收集效率。

到目前为止，**Serial收集器依然是Client模式下的默认的新生代垃圾收集器。**

### ParNew收集器---Server模式下的虚拟机首选
ParNew收集器是Serial收集器的多线程版本，ParNew收集器的工作示意图如下：

![ParNew](http://p7vxw6hv7.bkt.clouddn.com/18-7-2/7903329.jpg)

**ParNew收集器是许多运行在Server模式下的虚拟机中首选的新生代收集器。**除去性能因素，很重要的原因是除了Serial收集器外，目前只有它能与CMS收集器配合工作。

但是，在单CPU环境中，ParNew收集器绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百地保证可以超越Serial收集器。然而，随着可以使用的CPU的数量的增加，它对于GC时系统资源的有效利用还是很有好处的。

### Parallel Scavenge收集器---吞吐量
新生代，使用复制算法，并行的多线程。

与ParNew收集器相比，很多相似之处，但是Parallel Scavenge收集器更关注可控制的**吞吐量**。吞吐量越大，垃圾收集的时间越短，则用户代码则可以充分利用CPU资源，尽快完成程序的运算任务。

Parallel Scavenge收集器使用两个参数控制吞吐量：

- XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间
-  XX:GCRatio 直接设置吞吐量的大小。

直观上，只要最大的垃圾收集停顿时间越小，吞吐量是越高的，但是**GC停顿时间的缩短是以牺牲吞吐量和新生代空间作为代价的。**比如原来10秒收集一次，每次停顿100毫秒，现在变成5秒收集一次，每次停顿70毫秒。停顿时间下降的同时，吞吐量也下降了。

除此之外，Parallel Scavenge收集器还可以设置参数-XX:+UseAdaptiveSizePocily来动态调整停顿时间或者最大的吞吐量，这种方式称为**GC自适应调节策略**，这点是ParNew收集器所没有的。

### Serial Old收集器
Serial Old收集器是Serial收集器的老年代版本，也是一个单线程收集器，采用“标记-整理算法”进行回收。其运行过程与Serial收集器一样。

Serial Old收集器的主要意义也是在于给Client模式下的虚拟机使用。

如果在Server模式下，那么它主要还有两大用途：
1. 用途是在JDK 1.5以及之前的版本中与Parallel Scavenge收集器搭配使用
2. 用途就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。

### Parallel Old收集器

Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法进行垃圾回收。其通常与Parallel Scavenge收集器配合使用，“吞吐量优先”收集器是这个组合的特点，在注重**吞吐量和CPU资源敏感**的场合，都可以使用这个组合。

![Parallel Old](http://p7vxw6hv7.bkt.clouddn.com/18-7-2/17746777.jpg)

### CMS（Concurrent Mark Sweep）收集器---停顿时间
CMS收集器（Concurrent Mark Sweep）的目标就是**获取最短回收停顿时间**。在注重服务器的响应速度，希望停顿时间最短，则CMS收集器是比较好的选择。

整个执行过程分为以下4个步骤：
- 初始标记
标记GC Roots能够关联到的对象
- 并发标记
执行GC Roots Tracing的过程
- 重新标记
修正并发标记期间因用户程序执行而导致标记发生变动使得标记错误的记录
- 并发清除


其中，初始标记和重新标记这两个步骤仍然需要暂停Java执行线程

其执行过程如下：

![CMS](http://p7vxw6hv7.bkt.clouddn.com/18-7-2/98444993.jpg)

由上图可知，整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，因此，总体上CMS收集器的内存回收过程是与用户线程一起并发执行的。

#### CMS的优点
**CMS的优点很明显：并发收集、低停顿。**由于进行垃圾收集的时间主要耗在并发标记与并发清除这两个过程，虽然初始标记和重新标记仍然需要暂停用户线程，但是从总体上看，这部分占用的时间相比其他两个步骤很小，所以可以认为是低停顿的。

#### CMS的缺点
- 对CPU资源太敏感，这点可以这么理解，虽然在并发标记阶段用户线程没有暂停，但是由于收集器占用了一部分CPU资源，导致程序的响应速度变慢
- CMS收集器无法处理浮动垃圾。所谓的“浮动垃圾”，就是在并发标记阶段，由于用户程序在运行，那么自然就会有新的垃圾产生，这部分垃圾被标记过后，CMS无法在当次集中处理它们（为什么？原因在于CMS是以获取最短停顿时间为目标的，自然不可能在一次垃圾处理过程中花费太多时间），只好在下一次GC的时候处理。这部分未处理的垃圾就称为“浮动垃圾”
- 由于CMS收集器是基于“标记-清除”算法的，前面说过这个算法会导致大量的空间碎片的产生，一旦空间碎片过多，大对象就没办法给其分配内存,那么即使内存还有剩余空间容纳这个大对象，但是却没有连续的足够大的空间放下这个对象，所以虚拟机就会触发一次Full GC。通过控制参数`XX:+UseCMSCompactAtFullCollection`解决这个问题，用于在CMS垃圾收集器顶不住要进行FullGC的时候开启空间碎片的合并整理过程。

## G1收集器

G1（Garbage-First）收集器是现今收集器技术的最新成果之一，之前一直处于实验阶段，直到jdk7u4之后，才正式作为商用的收集器。

与前几个收集器相比，G1收集器有以下特点：

*   并行与并发
*   分代收集（仍然保留了分代的概念）
*   空间整合（整体上属于“标记-整理”算法，不会导致空间碎片）
*   可预测的停顿（比CMS更先进的地方在于能让使用者明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒）

此外，G1收集器将Java堆划分为多个大小相等的Region（独立区域），新生代与老年代都是一部分Region的集合，G1的收集范围则是这一个个Region（化整为零）。

G1的工作过程如下：

- 初始标记（Initial Marking）
- 并发标记（Concurrent Marking）
- 最终标记（Final Marking）
- 筛选回收（Live Data Counting and Evacuation）

初始标记阶段仅仅只是标记一下GC Roots能够直接关联的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段的用户程序并发运行的时候，能在正确可用的Region中创建对象，这个阶段需要暂停线程。并发标记阶段从GC Roots进行可达性分析，找出存活的对象，这个阶段食欲用户线程并发执行的。最终标记阶段则是修正在并发标记阶段因为用户程序的并发执行而导致标记产生变动的那一部分记录，这部分记录被保存在Remembered Set Logs中，最终标记阶段再把Logs中的记录合并到Remembered Set中，这个阶段是并行执行的，仍然需要暂停用户线程。最后在筛选阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间制定回收计划。整个执行过程如下：

![G1](http://p7vxw6hv7.bkt.clouddn.com/18-7-2/62387690.jpg)

# 六. 内存分配与回收策略---when

## 回收策略

策略
> 1.  Minor GC、
> 2.  Major GC/Full GC

Minor GC：发生在新生代的GC，发生非常频繁，消耗时间短。 
Major GC：发生在老年代GC，消耗时间一般为新生代GC的10倍，甚至更多（1000倍）。
Full GC：新生代+老年代 GC 。 一般情况MajorGC是由MinorGC触发，所以MajorGC一般（也有一些收集器直接进行Major GC）会伴随一次Minor GC，所以也写成Major GC/Full GC。

## 内存分配
Java技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题：给对象分配内存以及回收分配给对象的内存。

对象的内存分配，往大方向讲，就是在堆上分配，对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。


### 1. 对象优先在Eden分配
- 大多数情况下，对象在新生代Eden区分配。
- 当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。

### 2. 大对象直接进入老年代
所谓的大对象就是指需要**大量连续内存空间**的Java对象，最典型的大对象就是那种很长的字符串和数组，经常产生大对象容易导致额外的GC操作。
JVM中提供了一个`-XX：PretenureSizeThreshold`参数（这个参数只对Serial和ParNew这两个新生代垃圾收集器有效），令大于这个参数的对象直接在老年代中分配，这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝。


### 3. 长期存活的对象将进入老年代
JVM给了每个对象一个“年龄计数器”，所谓的年龄计数器就是指，这个对象熬过第一次GC，并且进入了Survivor区中，那么就将这个对象的年龄设为1，之后，每熬过一次GC，年龄+1，当这个值到达一个阀值（默认15，可通过`-XX：MaxTenuringThreshold`来设置）时，这个对象就会被移到老年代中。


### 4. 动态对象年龄判定
为了更好的适应不同程序的内存状况，JVM也不是要去一个对象必须达到MaxTenuringThreshold设置的年龄阀值才能进入老年代。
如果Survivor中的对象满足同年龄（比如N）对象所占空间达到了Survivor总空间的一半的时候，那么年龄大于或者等于N的对象都可以进入老年代，无需等待阀值

### 5. 空间分配担保
在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。


















参考文章
周志明，深入理解Java虚拟机：JVM高级特性与最佳实践，机械工业出版社
[JVM学习笔记（三）垃圾收集器与内存分配策略](http://geosmart.github.io/2016/03/09/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/)
[【深入理解JVM】：垃圾收集（GC）概述](https://blog.csdn.net/u011080472/article/details/51322855)