---
title: JMM及happens-before
date: 2018-09-25 23:07:03
tags: 并发
categories: 并发
---
本文主要介绍JMM、线程安全需要满足的三大原则、happens-before规则。

<!-- more -->

# 一. 为什么要了解JMM(`Java Memory Model`)
**线程安全**： 当多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替运行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，**调用这个对象的行为都可以获取正确的结果**，那这个对象是线程安全的。

出现线程安全的问题一般是因为**主内存和工作内存数据不一致性**和**重排序**导致的，而解决线程安全的问题最重要的就是理解这两种问题是怎么来的，理解它们的核心在于理解java内存模型（JMM）。

在多线程条件下，多个线程肯定会相互协作完成一件事情，一般来说就会涉及到**多个线程间相互通信告知彼此的状态以及当前的执行结果**等，另外，为了性能优化，还会**涉及到编译器指令重排序和处理器指令重排序**。

Java内存模型(即，简称JMM)本身是一种抽象的概念，**并不真实存在，它描述的是一组规则或规范**，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。

由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据。
**而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行**
首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，**线程间的通信(传值)必须通过主内存来完成**

# 二. JMM是--内存模型抽象结构
我们知道**CPU的处理速度**和**主存的读写速度**不是一个量级的，为了平衡这种巨大的差距，每个CPU都会有缓存。因此，共享变量会先放在主存中，每个线程都有属于自己的工作内存，并且会把位于主存中的共享变量拷贝到自己的工作内存，之后的读写操作均使用位于工作内存的变量副本，并在某个时刻将工作内存的变量副本写回到主存中去。JMM就从抽象层次定义了这种方式，并且JMM决定了一个线程对共享变量的写入何时对其他线程是可见的。

![JMM](http://upload-images.jianshu.io/upload_images/11861611-229a608295b37f6a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

如图为JMM抽象示意图，**线程A和线程B之间要完成通信的话，要经历如下两步**：

1.  线程A从主内存中将共享变量读入线程A的工作内存后并进行操作，之后将数据重新写回到主内存中；
2.  线程B从主存中读取最新的共享变量

从横向去看看，线程A和线程B就好像通过共享变量在进行隐式通信。这其中有很有意思的问题，如果线程A更新后数据并没有及时写回到主存，而此时线程B读到的是过期的数据，这就出现了“脏读”现象。可以通过同步机制（控制不同线程间操作发生的相对顺序）来解决或者通过volatile关键字使得每次volatile变量都能够强制刷新到主存，从而对每个线程都是可见的。

# 三. 内存模型三大特性

## 1. 原子性

Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，也就是说对这部分数据的操作可以不具备原子性。

AtomicInteger、AtomicLong、AtomicReference 等特殊的原子性变量类提供了下面形式的原子性条件更新语句，使得**比较和更新**这两个操作能够不可分割地执行。

```java
boolean compareAndSet(expectedValue, updateValue);
```

AtomicInteger 使用举例：

```java
private AtomicInteger ai = new AtomicInteger(0);
public int next() {
    return ai.addAndGet(2)
}
```

也可以使用 synchronized 同步操作来保证操作具备原子性，它对应的虚拟机字节码指令为 monitorenter 和 monitorexit。

### 2. 可见性

如果没有及时地对主内存与工作内存的数据进行同步，那么就会出现不一致问题。如果存在不一致的问题，一个线程对一个共享数据所做的修改就不能被另一个线程看到。

volatile 可以保证可见性，它
- 在`修改`一个共享数据时会将该值从工作内存同步到主内存
- 对一个共享数据进行`读取`时会先从主内存同步到工作内存

synchronized 也能够保证可见性，他能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主内存当中。
不过只有对共享变量的 set() 和 get() 方法都加上 synchronized 才能保证可见性，**如果只有 set() 方法加了 synchronized，那么 get() 方法并不能保证会从内存中读取最新的数据**。（可见性问题，参看下面博客）

[Java并发编程实战](https://blog.csdn.net/ns_code/article/details/17288243)

### 3. 有序性

在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。

volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。

也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。

# 四. 重排序

一个好的内存模型实际上会放松对处理器和编译器规则的束缚，也就是说软件技术和硬件技术都为同一个目标而进行奋斗：在不改变程序执行结果的前提下，尽可能提高并行度。JMM对底层尽量减少约束，使其能够发挥自身优势。因此，在执行程序时，**为了提高性能，编译器和处理器常常会对指令进行重排序**。一般重排序可以分为如下三种：

![重排序](http://upload-images.jianshu.io/upload_images/11861611-9a151bbe0925967d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

1.  编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序；
2.  指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果**不存在数据依赖性**，处理器可以改变语句对应机器指令的执行顺序；
3.  内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。

如图，1属于编译器重排序，而2和3统称为处理器重排序。这些重排序会导致线程安全的问题。
**针对编译器重排序**，JMM的编译器重排序规则会禁止一些**特定类型的编译器重排序**；
**针对处理器重排序**，编译器在生成指令序列的时候会通过**插入内存屏障指令来禁止某些特殊的处理器重排序**。

那么什么情况下，不能进行重排序了？下面就来说说数据依赖性。有如下代码：

> double pi = 3.14 //A
> 
> double r = 1.0 //B
> 
> double area = pi * r * r //C

这是一个计算圆面积的代码，由于A,B之间没有任何关系，对最终结果也不会存在关系，它们之间执行顺序可以重排序。因此可以执行顺序可以是A->B->C或者B->A->C执行最终结果都是3.14，即A和B之间没有数据依赖性。具体的定义为：**如果两个操作访问同一个变量，且这两个操作有一个为写操作，此时这两个操作就存在数据依赖性**这里就存在三种情况：1\. 读后写；2.写后写；3\. 写后读，者三种操作都是存在数据依赖性的，如果重排序会对最终执行结果会存在影响。**编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖性关系的两个操作的执行顺序**

另外，还有一个比较有意思的就是**as-if-serial**语义。

**as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提供并行度），（单线程）程序的执行结果不能被改变**。编译器，runtime和处理器都必须遵守as-if-serial语义。as-if-serial语义把单线程程序保护了起来，**遵守as-if-serial语义的编译器，runtime和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的**。比如上面计算圆面积的代码，在单线程中，会让人感觉代码是一行一行顺序执行上，实际上A,B两行不存在数据依赖性可能会进行重排序，即A，B不是顺序执行的。as-if-serial语义使程序员不必担心单线程中重排序的问题干扰他们，也无需担心内存可见性问题。

# 五. happens-before规则
除了可以用 volatile 和 synchronized 来保证有序性。除此之外，**JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。**

主要有以下这些原则：

## 1. 单一线程原则-- Single thread rule

在一个线程内，在程序前面的操作先行发生于后面的操作。

![image](http://upload-images.jianshu.io/upload_images/11861611-5927969588c7b7ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 2. 管程锁定规则--Monitor Lock Rule

一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。

![image](http://upload-images.jianshu.io/upload_images/11861611-afd14f60ec9292c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 3\. volatile 变量规则--Volatile Variable Rule

对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。

![image](http://upload-images.jianshu.io/upload_images/11861611-5d50fb7fa9a2c76a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 4\. 线程启动规则-- Thread Start Rule

Thread 对象的 start() 方法先行发生于此线程的每一个动作。

![image](http://upload-images.jianshu.io/upload_images/11861611-a3131b03eb792ffa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 5\. 线程加入规则--Thread Join Rule

join() 方法返回先行发生于 Thread 对象的结束。

![image](http://upload-images.jianshu.io/upload_images/11861611-8c9af39568d7ff78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 6\. 线程中断规则-- Thread Interruption Rule

对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 Thread.interrupted() 方法检测到是否有中断发生。

### 7\. 对象终结规则-- Finalizer Rule

一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。

### 8\. 传递性-- Transitivity

如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。

参考文章
[JAVA并发](https://www.bookstack.cn/read/Interview-Notebook/notes-Java%20%E5%B9%B6%E5%8F%91.md#%E5%9B%9B%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8D%8F%E4%BD%9C)
[全面理解Java内存模型(JMM)](https://blog.csdn.net/javazejian/article/details/72772461)


